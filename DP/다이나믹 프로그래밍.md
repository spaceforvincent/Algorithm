# DP

- 한 번 계산한 문제는 다시 계산하지 않도록 하는 알고리즘
- 중복되는 연산을 줄임 (메모리 공간을 약간 더 사용)

- 다이나믹 : '프로그램이 실행되는 도중에'
- 다이나믹 프로그래밍 사용가능 조건
  - 큰 문제를 작은 문제로 나눌 수 있다.
  - 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.



- 메모이제이션 (캐싱)
  - 다이나믹 프로그래밍을 구현하는 방법 중 한 종류
  - 한 번 구한 결과를 메모리 공간(리스트)에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져옴

```python
#피보나치 수열 : O(N)
dp = [0] * 100

def fibonacci(x):
    #종료조건
    if x == 1 or x == 2:
        return 1
    #이미 계산한 적 있는 문제라면 그대로 반환
    if dp[x] != 0:
        return dp[x]
    #아직 계산하지 않은 문제라면 점화식에 따라서 피보나치 결과 반환
    dp[x] = fibonacci(x-1) + fibonacci(x-2)
    
    return dp[x]
```

- 이처럼 재귀함수를 이용하여 DP 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 **탑다운**(하향식) 방식이라고 말한다.
  - 메모이제이션은 탑다운 방식에 국한되어 사용되는 표현



```
dp = [0] * 100

dp[1] = 1
dp[2] = 1
n = 99

for i in range(3, n+1) :
	dp[i] = dp[i-1] + dp[i-2]
```



- 이처럼 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **바텀업**(상향식) 방식이라고 말한다.

  - DP의 전형적인 형태는 바텀업 방식 (보다 권장되는 방식)

  

- 다이나믹 프로그램과 분할정복의 차이점은, 다이나믹 프로그래밍은 문제들이 서로 영향을 미치는 점이다.