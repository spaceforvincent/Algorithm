# DFS



- 스택 : FILO, LIFO
- 큐 : FIFO



 ### 재귀

- 자기자신을 다시 호출
- 종료 조건을 꼭 명시해야 한다.
- 내부적으로 스택 자료구조와 동일 
  - 스택 자료구조를 활용해야 하는 상당수 알고리즘은 재귀함수 이용하면 간편



### DFS

- 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘

  (최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작)

  - 그래프의 구조
    - 노드(정점)
    - 간선 : 두 노드가 간선으로 연결되어 있다면 ''두 노드는 인접하다''라고 표현
  - 인접행렬 : 2차원 배열로 그래프의 연결관계를 표현하는 방식 (메모리 비효율적 BUT 속도 빠름)
  - 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식 (메모리 효율적 BUT 속도 느림)

  

- 동작과정

  - 탐색 시작 노드를 스택에 삽입하고 방문처리

  - 현재 스택 최상단에 있는 노드에, 방문하지 않은 인접노드가 있으면 그 인접노드를 스택에 넣고 방문처리

    (방문하지 않은 인접노드가 없으면 스택에서 최상단 노드를 꺼냄) 

  - 2번의 과정을 더 이상 수행할 수 없을 때까지 반복



```python
def DFS(graph,v,visited):
    #현재 노드를 방문처리
    visited[v] = True
    
    #해야할 일 처리
    print(v, end=' ')
    
    #현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[v]:
            dfs(graph,i,visited)
            
#인접리스트생성
#visited 배열 생성
#정의된 DFS 함수 호출
```







### 2차원의 탐색문제를 만나면 그래프 형태로 바꿔서 생각한 다음 풀이법을 고민하자



### 백트래킹

- 해를 찾는 도중에 '막히면', 즉 해가 아닌 것이 확실해 지면, 다시 돌아가서 다시 해를 찾아가는 기법
- DFS에서 발전한 기법
  - 탐색 중에 오답을 만나면 이전 분기점으로 돌아가며, 시도해보지 않은 다른 해결방법이 있으면 시도한다. 
  - 해결 방법이 더 없으면 이전 분기점으로 돌아간다. 
  - 만일 모든 경우를 다 검사했을 경우에도 답을 찾지 못한다면 이 문제의 해결책은 없는 것이라고 판별할 수 있다.
- 메모리 공간은 DFS보다 덜 차지하게 되는데, 이는 현재의 상태를 보관하고 바꾸는 동안만 차지하기 때문이다.

- 더 이상 해가 나올 가능성이 없는 부분에 대해서는 더 이상 탐색하지 않도록 설계 (가지치기)
